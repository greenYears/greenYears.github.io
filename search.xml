<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot接入Nacos]]></title>
    <url>%2F3724281775%2F</url>
    <content type="text"><![CDATA[前言SpringBoot项目使用nacos作为配置中心和服务注册中心，同时兼容dubbo的注册中心。本Demo项目使用的SpringBoot版本是2.3.9.RELEASE。 项目中没有使用nacos官方提供的方式使用SpringBoot的集成方式来进行集成，而是使用了Alibaba Spring Cloud的依赖包进行集成。原因是因为官网提供的SpringBoot集成方式中，同时使用配置中心和服务发现功能，会使得服务发现功能配置的部分属性冲突不生效。最直接的就是配置中心和服务发现功能不可以配置2个不同的namespace，会默认选择使用配置中心中配置的namespace作为服务发现的namespace。 另外一点就是可以很好的和Spring的注解兼容，无需额外的注解。例如@NacosValue注解。 maven依赖123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config-server&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.9&lt;/version&gt;&lt;/dependency&gt; Nacos配置中心配置文件新建bootstrap.properties文件，在配置文件中配置nacos的配置信息。 123456# ============== nacos-config ============== #spring.cloud.nacos.config.server-addr=127.0.0.1:8848spring.cloud.nacos.config.username=nacosspring.cloud.nacos.config.password=nacosspring.cloud.nacos.config.namespace=config-devspring.cloud.nacos.config.group=demeter 注意：由于spring cloud alibaba nacos config的加载机制问题，配置信息如果写在了application-{env}.properties的配置文件中无法被解析。所以如果需要分多环境动态加载，可以写在bootstrap-{env}.properties文件中。启动的时候配置active profiles+ 环境就可以正确读取配置了 动态配置新建配置在名为config-dev的namespace中新建配置demeter-application-admin。 配置中的data-id就不再多说了，这个可以查看资料，网上有很多资料进行了详细描述。data-id参考如下： demeter-application-admin demeter-application-admin.properties demeter-application-admin-dev.properties 配置实体类DemeterAdminProperties.class 123456789@Data@Accessors(chain = true)@ConfigurationProperties(prefix = "demeter.admin")public class DemeterAdminProperties implements Serializable &#123; private static final long serialVersionUID = 1563821704172888362L; private String name; private String description; private String time;&#125; 使配置生效。@EnableConfigurationProperties注解使DemeterAdminProperties可以被实例化，自动注入到其他组件中。 12345678@Configuration@ComponentScan(value = &#123; "org.demeter.application.admin",&#125;)@Import(value = &#123;AutoRedisConfiguration.class&#125;)@EnableConfigurationProperties(&#123;DemeterAdminProperties.class&#125;)public class AdminWebConfig &#123;&#125; 访问结果Controller结果 Nacos服务发现配置文件123456# ============== nacos-discovery ============== #spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848spring.cloud.nacos.discovery.username=nacosspring.cloud.nacos.discovery.password=nacosspring.cloud.nacos.discovery.namespace=discovery-devspring.cloud.nacos.discovery.group=demeter 使配置生效使用@EnableDiscoveryClient注解使配置文件能够生效. 结果]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Nacos</tag>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis自定义Mapper和MapperTemplate实现通用sql]]></title>
    <url>%2F2928152990%2F</url>
    <content type="text"><![CDATA[最近项目中开始对接阿里开源的seata分布式事务框架，对接的时候使用update更新数据库记录的时候，应用出现了报错update pk value is not supported!，意思是我使用的tk.mybatis.mapper框架中的updateByExampleSelective等一系列的update语句均会对id进行更新操作，如： 1update tableName set id=id, ... 网上查询资料，决定自定义update的通用方法来解决这个问题。 自定义provider首先新建一个类来生成对应的update语句。其中包含了4个update方法： updateByPrimaryKeySpecial对应updateByPrimaryKey方法 updateByPrimaryKeySelectiveSpecial对应updateByPrimaryKeySelective方法 updateByExampleSelectiveSpecial对应updateByExampleSelective updateByExampleSpecial对应updateByExample方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.gugu.core.mybatis.provider;import com.gugu.core.mybatis.mapperhelper.SqlHelper;import org.apache.ibatis.mapping.MappedStatement;import tk.mybatis.mapper.mapperhelper.MapperHelper;import tk.mybatis.mapper.mapperhelper.MapperTemplate;/** * 特殊的更新. * &lt;p/&gt; * SpecialUpdateProvider * * @author zhoumeiqin * @date 2020/11/17 */public class SpecialUpdateProvider extends MapperTemplate &#123; public SpecialUpdateProvider(Class&lt;?&gt; mapperClass, MapperHelper mapperHelper) &#123; super(mapperClass, mapperHelper); &#125; public String updateByPrimaryKeySpecial(MappedStatement ms) &#123; Class&lt;?&gt; entityClass = this.getEntityClass(ms); StringBuilder sql = new StringBuilder(); sql.append(SqlHelper.updateTable(entityClass, this.tableName(entityClass))); sql.append(SqlHelper.updateSetColumns(entityClass, (String)null, false, false)); sql.append(SqlHelper.wherePKColumns(entityClass, true)); return sql.toString(); &#125; public String updateByPrimaryKeySelectiveSpecial(MappedStatement ms) &#123; Class&lt;?&gt; entityClass = this.getEntityClass(ms); StringBuilder sql = new StringBuilder(); sql.append(SqlHelper.updateTable(entityClass, this.tableName(entityClass))); sql.append(SqlHelper.updateSetColumns(entityClass, (String)null, true, this.isNotEmpty())); sql.append(SqlHelper.wherePKColumns(entityClass, true)); return sql.toString(); &#125; public String updateByExampleSelectiveSpecial(MappedStatement ms) &#123; Class&lt;?&gt; entityClass = this.getEntityClass(ms); StringBuilder sql = new StringBuilder(); if (this.isCheckExampleEntityClass()) &#123; sql.append(SqlHelper.exampleCheck(entityClass)); &#125; if (this.getConfig().isSafeUpdate()) &#123; sql.append(SqlHelper.exampleHasAtLeastOneCriteriaCheck("example")); &#125; sql.append(SqlHelper.updateTable(entityClass, this.tableName(entityClass), "example")); sql.append(SqlHelper.updateSetColumns(entityClass, "record", true, this.isNotEmpty())); sql.append(SqlHelper.updateByExampleWhereClause()); return sql.toString(); &#125; public String updateByExampleSpecial(MappedStatement ms) &#123; Class&lt;?&gt; entityClass = this.getEntityClass(ms); StringBuilder sql = new StringBuilder(); if (this.isCheckExampleEntityClass()) &#123; sql.append(SqlHelper.exampleCheck(entityClass)); &#125; if (this.getConfig().isSafeUpdate()) &#123; sql.append(SqlHelper.exampleHasAtLeastOneCriteriaCheck("example")); &#125; sql.append(SqlHelper.updateTable(entityClass, this.tableName(entityClass), "example")); sql.append(SqlHelper.updateSetColumns(entityClass, "record", false, false)); sql.append(SqlHelper.updateByExampleWhereClause()); return sql.toString(); &#125;&#125; 这里因为场景问题，这里copy了一份mybatis中的SqlHelper中的代码只修改了updateSetColumns()的方法中对于主键的更新处理 1234567891011121314if (!column.isId() &amp;&amp; column.isUpdatable()) &#123; if (column == versionColumn) &#123; Version version = (Version) versionColumn.getEntityField().getAnnotation(Version.class); String versionClass = version.nextVersion().getCanonicalName(); sql.append(column.getColumn()).append(" = $&#123;@tk.mybatis.mapper.version.VersionUtil@nextVersion(\"").append(versionClass).append("\", ").append(column.getProperty()).append(")&#125;,"); &#125; else if (notNull) &#123; sql.append(getIfNotNull(entityName, column, column.getColumnEqualsHolder(entityName) + ",", notEmpty)); &#125; else &#123; sql.append(column.getColumnEqualsHolder(entityName) + ","); &#125;&#125; else if (column.isId()) &#123; // update 语句不应该修改主键信息 // sql.append(column.getColumn()).append(" = ").append(column.getColumn()).append(",");&#125; 新建自定义Mapper123456789101112131415161718192021222324252627282930package com.gugu.core.mybatis.mapper;import com.gugu.core.mybatis.provider.SpecialUpdateProvider;import org.apache.ibatis.annotations.Param;import org.apache.ibatis.annotations.UpdateProvider;import tk.mybatis.mapper.annotation.RegisterMapper;/** * 特殊的更新. * &lt;p/&gt; * SpecialUpdateMapper * * @author zhoumeiqin * @date 2020/11/17 */@RegisterMapperpublic interface SpecialUpdateMapper&lt;T&gt; &#123; @UpdateProvider(type = SpecialUpdateProvider.class, method = "dynamicSQL") int updateByPrimaryKeySpecial(T var1); @UpdateProvider(type = SpecialUpdateProvider.class, method = "dynamicSQL") int updateByPrimaryKeySelectiveSpecial(T var1); @UpdateProvider(type = SpecialUpdateProvider.class, method = "dynamicSQL") int updateByExampleSelectiveSpecial(@Param("record") T var1, @Param("example") Object var2); @UpdateProvider(type = SpecialUpdateProvider.class, method = "dynamicSQL") int updateByExampleSpecial(@Param("record") T var1, @Param("example") Object var2);&#125; SpringBoot中配置Mybatis默认只支持tk.mybatis.mapper.common.Mapper，会报错误。 12Error invoking SqlProvider method (tk.mybatis.mapper.provider.SpecialProvider.dynamicSQL)java.lang.NoSuchMethodException: tk.mybatis.mapper.provider.SpecialProvider.&lt;init&gt;()]]></content>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过注解实现策略模式，解决不同消息不同类处理]]></title>
    <url>%2F2471769430%2F</url>
    <content type="text"><![CDATA[项目中需要对不同类型的消息进行不同的处理，这个也是也最常见的订单创建问题是一致的。最初级的办法就是使用 if…else 或者 switch 来实现逻辑，但是后面类型越来越多的时候，if…else 就显得有些过于臃肿也不易于维护了。最主要的可能就是不能体现实现者的技术能力。所以此时就需要使用策略模式来装一装了。 基础接口定义策略模式最关键的一点就是所有的实现类都要实现同一个接口。 1234567891011121314151617181920package com.gugu.boy.spring.websocket.handler.processor;import com.gugu.boy.spring.websocket.MessagePayload;import org.springframework.web.socket.WebSocketSession;/** * 发送socket消息 template. * * @author zhoumeiqin * @date 2019/10/14 */public interface PayloadProcessor &#123; /** * 执行. * * @param session * @param payload */ void process(WebSocketSession session, MessagePayload payload) throws Exception;&#125; 注解定义定义注解，通过注解上的类型，来使实现类支持对应类型的消息处理。 123456789101112131415package com.gugu.boy.spring.websocket.handler.processor;import java.lang.annotation.*;/** * @author zhoumeiqin * @date 2019/10/14 */@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inheritedpublic @interface ProcessorSupport &#123; int[] types();&#125; 实现类的定义123456789101112@Slf4j@Component@ProcessorSupport(types = &#123;PayloadConst.Type.TASK_ASSIGN, PayloadConst.Type.APPROVAL_RESULT&#125;)public class CommonPayloadProcessor implements PayloadProcessor &#123; @Override public void process(WebSocketSession session, MessagePayload payload) throws Exception &#123; String context = JSON.toJSONString(payload); TextMessage message = new TextMessage(context); session.sendMessage(message); &#125;&#125; 1234567891011@Slf4j@Component@ProcessorSupport(types = &#123;PayloadConst.Type.SCENE_REFRESH, PayloadConst.Type.ALERT_ACTION&#125;)public class PopularProcessor implements PayloadProcessor &#123; @Override public void process(WebSocketSession session, MessagePayload payload) throws Exception &#123; String context = JSON.toJSONString(payload); TextMessage message = new TextMessage(context); session.sendMessage(message); &#125;&#125; Context 实现Context 的目的在于在程序启动的时候，将所有带有注解ProcessorSupport的PayloadProcessor类型的实例管理起来，通过ProcessorSupport的 type 支持的类型，快速定位到对应的实例上，从而实现对应的逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.gugu.boy.spring.websocket.handler;import com.github.greenyears.core.utils.AssertUtils;import com.gugu.boy.spring.websocket.handler.processor.PayloadProcessor;import com.gugu.boy.spring.websocket.handler.processor.ProcessorSupport;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.BeansException;import org.springframework.boot.CommandLineRunner;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.stereotype.Component;import java.util.Collection;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * 消息文本处理上下文. * * @author zhoumeiqin * @date 2019/10/14 */@Slf4j@Componentpublic class PayloadProcessorContext implements CommandLineRunner, ApplicationContextAware &#123; private volatile ApplicationContext applicationContext; private static final Map&lt;Integer, PayloadProcessor&gt; processorMap = new ConcurrentHashMap&lt;&gt;(); public PayloadProcessorContext(ApplicationContext applicationContext) &#123; this.applicationContext = applicationContext; &#125; @Override public void run(String... args) throws Exception &#123; this.initialization(); &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; /** * 初始化. */ private void initialization() &#123; Collection&lt;PayloadProcessor&gt; processors = this.applicationContext.getBeansOfType(PayloadProcessor.class).values(); processors.forEach(processor -&gt; &#123; Class&lt;? extends PayloadProcessor&gt; clazz = processor.getClass(); ProcessorSupport annotation = clazz.getAnnotation(ProcessorSupport.class); if (annotation != null) &#123; int[] types = annotation.types(); for (int type : types) &#123; processorMap.put(type, processor); &#125; &#125; &#125;); &#125; /** * 获取实例. * * @param type * @return */ public static PayloadProcessor getInstance(Integer type) &#123; PayloadProcessor processor = processorMap.get(type); AssertUtils.notNull(processor, "不支持的消息类型"); return processor; &#125;&#125; 使用方法使用方法很简单的了，只需要将消息中的 type 属性拿到，通过PayloadProcessorContext.getInstance()即可以获取到PayloadProcessor.process()方法去实现就行了，是不是比if...else高大上美观？ 1234567891011public synchronized void sendMessage(MessagePayload payload) &#123; log.info("发送消息给所有人.: &#123;&#125;", JSON.toJSONString(payload)); PayloadProcessor processor = PayloadProcessorContext.getInstance(payload.getType()); surveySessions.forEach((key, value) -&gt; &#123; try &#123; processor.process(value, payload); &#125; catch (Exception e) &#123; log.error("发送给用户消息失败: &#123;&#125;", JSON.toJSONString(value.getPrincipal()), e); &#125; &#125;);&#125;]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx支持websocket连接]]></title>
    <url>%2F3951353636%2F</url>
    <content type="text"><![CDATA[nginx 要支持 websocket 是很简单的，只需要增加 3 个配置就行。表明是 websocket 连接进入的时候，进行一个连接升级将 http 连接变成 websocket 的连接。前端就可以通过ws://xxxxx进行 socket 长连接了。 1234567location / &#123; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "Upgrade"; proxy_read_timeout 300s; ... &#125; 注意： 2 个 proxy_set_header 的设置需要放在 location 中，不要放在 server 中，否则的话不会生效。 使用nginx做websocket连接会有一个超时时间，默认是60s，即当60s内客户端和服务端没有消息通信会断开长连接。所以稍微设置长点超时时间，并在客户端定时发起心跳消息.]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot2+Spring Security集成WebSocket]]></title>
    <url>%2F1770992505%2F</url>
    <content type="text"><![CDATA[项目要求前端要做到自动刷新功能，low 的办法就是由前端做轮询。但是随着后面产品要求的实时通知越来越多，轮询已经渐渐不满足需求了，只能选择使用 socket 长链接了。 但是百度，Google 之后，发现大多数都是使用的 SocketJS 来实现的 socket，而前端使用的 React Native 只能使用 websocket 实现。没有办法，只能自己查阅资料实现了。 引入 Maven 依赖123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 兼容spring security的socket --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-messaging&lt;/artifactId&gt;&lt;/dependency&gt; websocket 配置 项目中有使用 Spring Security 作为登录权限验证，所以要先将 security 对 socket 的路径忽略掉，自己去做权限 12345678@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.csrf().disable() ... .antMatchers("/socket/**").permitAll() .antMatchers("/socket").permitAll() ...&#125; 以socket作为访问路径，允许所有远端访问 12345678910111213141516@Configuration@EnableWebSocketpublic class WebSocketConfig implements WebSocketConfigurer &#123; @Autowired private WebSocketMessageHandler webSocketMessageHandler; @Autowired private GuguHandshakeInterceptor handshakeInterceptor; @Override public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123; registry.addHandler(webSocketMessageHandler, "/socket") .addInterceptors(handshakeInterceptor) .setAllowedOrigins("*"); &#125;&#125; 开始实现 websocket 的接入websocket 的握手项目中使用了 security 做了登录用户的管理。所以限制只有登录的用户才能和服务端进行 websocket 链接，因此之前放在 http 请求头中的 token 信息要带到 websocket 中来，但是 websocket 中没有请求头参数的设置，因此只能将 token 信息放在链接地址中，类似与 get 请求。如ws://localhost:8080/socket?token={token}这样。所以，要在 websocket 和服务器建立连接的握手中去校验 token 的合法性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.gugu.boy.spring.websocket.interceptor;import com.gugu.boy.spring.security.GuguUserDetails;import com.gugu.boy.spring.security.authentication.storage.TokenStorage;import com.gugu.boy.spring.security.authentication.storage.UserCache;import com.gugu.boy.spring.security.authentication.token.TokenAuthenticationHandler;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.BeanUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.server.ServerHttpRequest;import org.springframework.http.server.ServerHttpResponse;import org.springframework.http.server.ServletServerHttpRequest;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.stereotype.Component;import org.springframework.web.socket.WebSocketHandler;import org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor;import java.util.ArrayList;import java.util.Map;/** * websocket握手. * * @author zmq * @date 2019/10/14 */@Slf4j@Componentpublic class GuguHandshakeInterceptor extends HttpSessionHandshakeInterceptor &#123; @Autowired private TokenAuthenticationHandler tokenUtils; @Autowired private TokenStorage tokenStorage; @Override public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes) throws Exception &#123; ServletServerHttpRequest serverRequest = (ServletServerHttpRequest) request; // websocket的token信息不能想 String token = serverRequest.getServletRequest().getParameter("token"); boolean authentication = this.authentication(token, attributes); if (authentication) &#123; log.info("握手成功"); return super.beforeHandshake(request, response, wsHandler, attributes); &#125; else &#123; log.warn("握手失败"); &#125; return false; &#125; @Override public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception exception) &#123; &#125; private boolean authentication(String token, Map&lt;String, Object&gt; attributes) &#123; if (StringUtils.isBlank(token)) &#123; log.warn("缺失参数: token"); return false; &#125; String id = tokenUtils.getFromToken(TokenAuthenticationHandler.CLAIM_KEY_ID, token); UserCache userCache = tokenStorage.getUserById(id); log.info("用户ID【&#123;&#125;】尝试进行握手", id); if (id != null &amp;&amp; userCache != null) &#123; GuguUserDetails userDetails = toUserDetails(userCache); if (token.equals(userCache.getToken())) &#123; //token中的用户信息和数据库中的用户信息对比成功后将用户信息加入SecurityContextHolder相当于登录 UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails.getPhone(), null, new ArrayList&lt;&gt;(0)); authentication.setDetails(userDetails); attributes.put("id", userDetails.getId()); attributes.put("username", userDetails.getPhone()); attributes.put("userType", userDetails.getUserType()); SecurityContextHolder.getContext().setAuthentication(authentication); return true; &#125; else &#123; log.warn("用户&#123;&#125;可能在其他设备上被登录了", id); &#125; &#125; log.warn("token信息：&#123;&#125;", token); return false; &#125; /** * 类型转换. * * @param source * @return UserCache * @author zhoumeiqin * @date 2019-07-30 10:21 **/ private GuguUserDetails toUserDetails(UserCache source) &#123; GuguUserDetails target = new GuguUserDetails(); BeanUtils.copyProperties(source, target); return target; &#125;&#125; 服务端针对前端通过 websocket 长链接发送的消息处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.gugu.boy.spring.websocket.handler;import com.alibaba.fastjson.JSON;import com.gugu.boy.spring.security.GuguUserDetails;import com.gugu.boy.spring.websocket.MessagePayload;import com.gugu.boy.spring.websocket.PayloadConst;import com.gugu.boy.spring.websocket.WebSocketContainer;import com.gugu.boy.spring.websocket.WebSocketTemplate;import com.gugu.core.exception.LogicException;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import org.springframework.web.socket.CloseStatus;import org.springframework.web.socket.TextMessage;import org.springframework.web.socket.WebSocketSession;import org.springframework.web.socket.handler.TextWebSocketHandler;/** * @author zhoumeiqin * @date 2019/10/14 */@Slf4j@Componentpublic class WebSocketMessageHandler extends TextWebSocketHandler &#123; @Autowired private WebSocketContainer container; @Autowired private WebSocketTemplate webSocketTemplate; @Override public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123; container.connect(session); super.afterConnectionEstablished(session); &#125; @Override public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception &#123; container.close(session, status); super.afterConnectionClosed(session, status); &#125; @Override public void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception &#123; GuguUserDetails user = container.getCurrentUser(session); MessagePayload payload = JSON.parseObject(message.getPayload(), MessagePayload.class); if (payload.getEvent() == PayloadConst.Event.HEARTBEAT) &#123; log.info("&#123;&#125; heartbeat", user.getPhone()); session.sendMessage(message); &#125; else &#123; try &#123; webSocketTemplate.sendMessage(payload); &#125; catch (LogicException e) &#123; log.warn("触发业务异常: &#123;&#125; - &#123;&#125;", e.getErrorCode(), e.getMessage()); &#125; catch (Exception e) &#123; log.error(",errMsg", e); &#125; &#125; &#125;&#125; 因为项目中需要有业务需要对固定的用户发送消息的需求，所以我针对 WebSocketSession 进行了集中管理。首先创建WebSocketContainer组件，将所有的 WebSocketSession 集中存储到ConcurrentHashMap中，以 userId 作为 Map 的 key，WebSocketSession 作为 value，这样就可以通过 Map 的特性可以快速找到对应 userId 的 WebSocketSession,从而将消息发送出去。当有客户端连接上来或者断开链接，都要增加 session 或者移除对应的 session。同时，启动一个只有 1 个线程的线程池，定时对 map 进行监控，可以定期展示当前链接人员。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235package com.gugu.boy.spring.websocket;import com.alibaba.fastjson.JSON;import com.gugu.boy.spring.security.GuguUserDetails;import com.gugu.boy.spring.websocket.handler.PayloadProcessorContext;import com.gugu.boy.spring.websocket.handler.processor.PayloadProcessor;import com.gugu.core.constants.SystemConstant;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.concurrent.BasicThreadFactory;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.stereotype.Component;import org.springframework.web.socket.CloseStatus;import org.springframework.web.socket.WebSocketSession;import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;import java.io.IOException;import java.security.Principal;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.ScheduledThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * @author zhoumeiqin * @date 2019/10/21 */@Slf4j@Componentpublic class WebSocketContainer &#123; private ScheduledExecutorService executor; /** * 查勘员在线session. * &lt;p&gt;key = user id &lt;/p&gt; */ private static Map&lt;Long, WebSocketSession&gt; surveySessions = new ConcurrentHashMap&lt;&gt;(); @PostConstruct public void init() &#123; this.monitor(); &#125; @PreDestroy public void destroy() &#123; if (this.executor != null) &#123; log.info("销毁定时器"); this.executor.shutdown(); &#125; &#125; /** * 监控. */ private void monitor() &#123; log.info("定时检测在线人数"); Runnable command = () -&gt; &#123; log.info("在线人数: &#123;&#125;", surveySessions.size()); log.info("在线人员：&#123;&#125;", surveySessions.keySet()); &#125;; executor = new ScheduledThreadPoolExecutor(1, new BasicThreadFactory.Builder().namingPattern("socket-mon-%d").daemon(true).build()); executor.scheduleAtFixedRate(command, 1, 5, TimeUnit.MINUTES); &#125; /** * 查勘员连接socket. * * @param user * @param session * @return * @throws IOException */ public void connect(GuguUserDetails user, WebSocketSession session) throws IOException &#123; WebSocketSession history = surveySessions.get(user.getId()); if (history != null) &#123; log.info("用户[&#123;&#125;]重复连接，关闭已有连接", user.getPhone()); history.close(WebSocketConst.Close.NORMAL); &#125; surveySessions.put(user.getId(), session); log.info("[&#123;&#125;]登录了, sessionId: &#123;&#125;，当前在线人数：&#123;&#125;", user.getPhone(), session.getId(), surveySessions.size()); &#125; /** * 连接. * * @param session * @throws IOException */ public void connect(WebSocketSession session) throws Exception &#123; GuguUserDetails user = this.getCurrentUser(session); if (user != null) &#123; this.connect(user, session); this.afterSocketConnect(user.getId()); &#125; else &#123; log.warn("当前用户未知"); &#125; &#125; /** * socket连接错误. * * @param userId */ public void afterSocketConnect(Long userId) throws Exception &#123; MessagePayload payload = new MessagePayload(); payload.setEvent(PayloadConst.Event.TO_SINGLE); payload.setType(PayloadConst.Type.SOCKET_CONNECT); payload.setToUser(userId); payload.setToUserType(SystemConstant.SURVEYOR); this.sendMessage(userId, payload); &#125; /** * close. * * @param userId */ public void close(Long userId) throws IOException &#123; WebSocketSession session = surveySessions.get(userId); if (session == null) &#123; log.warn("用户[&#123;&#125;]不在线", userId); return; &#125; session.close(WebSocketConst.Close.NORMAL); surveySessions.remove(userId); &#125; /** * 关闭. 默认4000，主动关闭，app不会进行连接重试. * * @param user */ public void close(GuguUserDetails user) throws IOException &#123; this.close(user, WebSocketConst.Close.NORMAL); &#125; /** * 关闭. * * @param user * @param status */ public void close(GuguUserDetails user, CloseStatus status) throws IOException &#123; if (user != null) &#123; log.info("连接关闭：&#123;&#125;, 关闭状态：&#123;&#125;", user.getPhone(), status); this.close(user.getId()); &#125; else &#123; log.warn("当前用户未知"); &#125; &#125; /** * 关闭连接. * * @param session * @param status */ public void close(WebSocketSession session, CloseStatus status) throws IOException &#123; GuguUserDetails user = this.getCurrentUser(session); this.close(user, status); &#125; /** * 获取session. * * @param userId * @return */ public WebSocketSession getSession(Long userId) &#123; return surveySessions.get(userId); &#125; /** * 发送消息给单独用户. * * @param userId * @param payload * @throws Exception */ public synchronized void sendMessage(Long userId, MessagePayload payload) throws Exception &#123; log.info("发送消息给用户：&#123;&#125;, 数据：&#123;&#125;", userId, JSON.toJSONString(payload)); WebSocketSession session = this.getSession(userId); if (session == null) &#123; log.warn("当前用户:&#123;&#125;不存在或者不在线", userId); return; &#125; PayloadProcessor processor = PayloadProcessorContext.getInstance(payload.getType()); processor.process(session, payload); &#125; /** * 发送消息给所有用户. * * @param payload */ public synchronized void sendMessage(MessagePayload payload) &#123; log.info("发送消息给所有人.: &#123;&#125;", JSON.toJSONString(payload)); PayloadProcessor processor = PayloadProcessorContext.getInstance(payload.getType()); surveySessions.forEach((key, value) -&gt; &#123; try &#123; processor.process(value, payload); &#125; catch (Exception e) &#123; log.error("发送给用户消息失败: &#123;&#125;", JSON.toJSONString(value.getPrincipal()), e); &#125; &#125;); &#125; /** * 获取当前用户. * * @param session * @return */ public GuguUserDetails getCurrentUser(WebSocketSession session) &#123; Principal principal = session.getPrincipal(); if (principal instanceof UsernamePasswordAuthenticationToken) &#123; UsernamePasswordAuthenticationToken authenticationToken = (UsernamePasswordAuthenticationToken) principal; return (GuguUserDetails) authenticationToken.getDetails(); &#125; else &#123; log.warn("未知的连接：&#123;&#125;", JSON.toJSONString(session.getPrincipal())); &#125; return null; &#125; /** * 是否在线. * * @param userId * @return */ public boolean isOnline(Long userId) &#123; return surveySessions.containsKey(userId); &#125;&#125; 最后再增加一个工具类WebSocketTemplate进行统一发送封装，目前功能比较简单，都是同步发送，后面可以追加线程池管理进行异步发送。 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.gugu.boy.spring.websocket;import com.alibaba.fastjson.JSON;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import java.io.IOException;/** * @author zhoumeiqin * @date 2019/10/21 */@Slf4j@Componentpublic class WebSocketTemplate &#123; @Autowired private WebSocketContainer container; /** * 发送消息. * * @param payload * @throws IOException */ public void sendMessage(MessagePayload payload) throws Exception &#123; if (payload.getEvent() == PayloadConst.Event.TO_SINGLE) &#123; container.sendMessage(payload.getToUser(), payload); &#125; else if (payload.getEvent() == PayloadConst.Event.TO_ALL) &#123; container.sendMessage(payload); &#125; &#125; /** * 关闭close. * * @param userId * @throws IOException */ public void close(Long userId) throws IOException &#123; log.info("断开用户&#123;&#125;的socket连接", userId); container.close(userId); &#125;&#125;]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp4对hexo压缩]]></title>
    <url>%2F2850879644%2F</url>
    <content type="text"><![CDATA[发现访问hexo变的很慢，就想着怎么对hexo进行静态文件压缩。 在最开始的时候，没有对静态文件进行压缩，会发现html文件中很多都是空白的字符。就在网上百度了很多攻略，发现都是使用的gulp3的方式进行压缩，而我npm依赖的gulp版本是gulp4版本： 123456"gulp": "^4.0.2","gulp-htmlclean": "^2.7.22","gulp-htmlmin": "^5.0.1","gulp-imagemin": "^6.0.0","gulp-minify-css": "^1.2.4","gulp-uglify": "^3.0.2", 然后按照网上的教程，执行gulp命令发现，会在控制台报错： 12345678910111213141516 ~/Mygit/personal/blog/maocaowu  gulpassert.js:350 throw err; ^AssertionError [ERR_ASSERTION]: Task function must be specified at Gulp.set [as _setTask] (/Users/zhoumeiqin/Mygit/personal/blog/maocaowu/node_modules/undertaker/lib/set-task.js:10:3) at Gulp.task (/Users/zhoumeiqin/Mygit/personal/blog/maocaowu/node_modules/undertaker/lib/task.js:13:8) at Object.&lt;anonymous&gt; (/Users/zhoumeiqin/Mygit/personal/blog/maocaowu/gulpfile.js:46:6) at Module._compile (internal/modules/cjs/loader.js:688:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:699:10) at Module.load (internal/modules/cjs/loader.js:598:32) at tryModuleLoad (internal/modules/cjs/loader.js:537:12) at Function.Module._load (internal/modules/cjs/loader.js:529:3) at Module.require (internal/modules/cjs/loader.js:636:17) at require (internal/modules/cjs/helpers.js:20:18) 本菜鸡又在网上找到了gulp的使用方法，发现只要将gulpfile.js稍加修改即可。原文： 123gulp.task('default', [ 'minify-html','minify-css','minify-js','minify-images']); 修改后： 1gulp.task('default',gulp.series(gulp.parallel('minify-html','minify-css','minify-js','minify-images'))); 最后再执行命令即可 123hexo clean &amp; hexo ggulphexo deploy 最后在public目录下查看构建出来的静态文件是否有压缩过即可。 如何使用gulp对静态文件进行压缩，参考博客https://blog.csdn.net/jinggege0818/article/details/82461795]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo图片懒加载方案]]></title>
    <url>%2F818282341%2F</url>
    <content type="text"><![CDATA[自从给hexo+next配置了背景图片之后，发现博客网站加载比较缓慢，就想着给图片添加上懒加载功能。 解决方案也很简单，就是通过依赖hexo-lazyload-image模块。 配置 新增hexo-lazyload-image模块 1npm install hexo-lazyload-image --save 在站点配置文件_config.yml增加配置 1234lazyload: enable: true onlypost: false loadingImg: /images/loading.png onlypost: 是否仅文章中的图片做懒加载, 如果为 false, 则主题中的其他图片, 也会做懒加载, 如头像, logo 等任何图片.loadingImg - 图片未加载时的代替图不填写使用默认加载图片, 如果需要自定义，添填入 loading 图片地址，如果是本地图片，不要忘记把图片添加到你的主题目录下。 Next 主题需将图片放到 \themes\next\source\images 目录下, 然后引用时: loadingImg: /images/图片文件名 文章转载自https://github.98.tn/hexo-lazyload/]]></content>
      <categories>
        <category>hexo</category>
        <category>next</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己写的工具类]]></title>
    <url>%2F1202052089%2F</url>
    <content type="text"><![CDATA[自己写了一个第三方工具类，避免自己每次写项目都要自己再copy一次这个工具类。 项目地址https://github.com/greenYears/zmq-commons-utils 使用方式Maven引用12345&lt;dependency&gt; &lt;groupId&gt;com.github.greenyears&lt;/groupId&gt; &lt;artifactId&gt;zmq-commons-utils&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt;&lt;/dependency&gt; Gradle引用1compile group: 'com.github.greenyears', name: 'zmq-commons-utils', version: '1.0.1' 简介异常 ApiException提供统一封装的api异常，各个业务可以根据自己的业务需求进行捕获处理。 工具类 AssertUtils断言类，可以针对常见的判断表达式进行断言，抛出ApiException以及自定义message。 BigDecimalUtils数据处理类。 CalculateUtils使用Java8提供的方法，处理日期的工具类。 AesUtils提供Aes加密解密的工具类。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重新编译nginx]]></title>
    <url>%2F860202933%2F</url>
    <content type="text"><![CDATA[最近服务器上发现了/var/tmp/nginx目录下有东西被linux服务器定时清理掉了，导致前端页面访问服务器接口的时候报错了。现在要对nginx目录重新编译一遍，重新指定http-client-body-temp-path, http-proxy-temp-path, http-fastcgi-temp-path, http-uwsgi-temp-path几个编译参数 重新编译首先要找到当初源码编译的时候的编译安装命令。如: 1234567891011./configure --prefix=/usr/local/nginx--pid-path=/var/nginx/run/nginx.pid --lock-path=/var/nginx/lock/nginx.lock --with-http_ssl_module --with-http_stub_status_module --with-http_gzip_static_module --http-client-body-temp-path=/var/nginx/tmp/nginx/client --http-proxy-temp-path=/var/nginx/tmp/nginx/proxy --http-fastcgi-temp-path=/var/nginx/tmp/nginx/fastcgi --http-uwsgi-temp-path=/var/nginx/tmp/nginx/uwsgi 这里也提醒了我们，在服务器上安装任何东西的时候，都要做好安装笔记，防止后面的时候需要用到的时候丢失！！！这里忘了也没有关系,使用nginx -V命令中能够查看到当初的编译命令配置 进入nginx源码包 如果源码包被清理掉了，那就重新下载新的源码包。查看nginx版本 1234567[root@izbp1j3sk6yysftuzun199z sbin]# /usr/local/nginx/sbin/nginx -Vnginx version: nginx/1.9.9built by gcc 4.8.5 20150623 (Red Hat 4.8.5-28) (GCC)built with OpenSSL 1.0.2k-fips 26 Jan 2017TLS SNI support enabledconfigure arguments: --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_module[root@izbp1j3sk6yysftuzun199z sbin]# 使用wget http://nginx.org/download/nginx-1.9.9.tar.gz下载 进入nginx源码包，将要编译的参数修改后，新增的参数追加在后面 1234567891011./configure --prefix=/usr/local/nginx--pid-path=/var/nginx/run/nginx.pid --lock-path=/var/nginx/lock/nginx.lock --with-http_ssl_module --with-http_stub_status_module --with-http_gzip_static_module --http-client-body-temp-path=/usr/local/nginx/temp/nginx/client --http-proxy-temp-path=/usr/local/nginx/temp/nginx/proxy --http-fastcgi-temp-path=/usr/local/nginx/temp/nginx/fastcgi --http-uwsgi-temp-path=/usr/local/nginx/temp/nginx/uwsgi 再执行make命令 注意：千万不要执行make install,否则就覆盖安装了 1[root@izbp1j3sk6yysftuzun199z nginx-1.9.9]# make make执行完成之后，源码目录会生成一个objs目录,里面有个nginx可执行文件，这个就是我们需要的新版本程序了。接下来我们就可以准备将新版本的nginx替换掉老版本的nginx了。 123456[root@izbp1j3sk6yysftuzun199z nginx-1.9.9]# lsauto CHANGES CHANGES.ru conf configure contrib html LICENSE Makefile man objs README src[root@izbp1j3sk6yysftuzun199z nginx-1.9.9]# cd objs/[root@izbp1j3sk6yysftuzun199z objs]# lsautoconf.err Makefile nginx nginx.8 ngx_auto_config.h ngx_auto_headers.h ngx_modules.c ngx_modules.o src[root@izbp1j3sk6yysftuzun199z objs]# 备份老版本的nginx先将老版本的nginx进行备份，防止出现了问题，好进行复原操作。 1[root@izbp1j3sk6yysftuzun199z objs]# cp /usr/local/nginx/sbin/nginx /usr/local/nginx/nginx.bak 覆盖旧的nginx 1[root@izbp1j3sk6yysftuzun199z objs]# cp ./nginx /usr/local/nginx/sbin/nginx 如果提示文本文件忙的错误，建议以下命令： 123456[root@izbp1j3sk6yysftuzun199z objs]# cp ./nginx /usr/local/nginx/sbin/nginxcp：是否覆盖"/usr/local/nginx/sbin/nginx"？ yescp: 无法创建普通文件"/usr/local/nginx/sbin/nginx": 文本文件忙[root@izbp1j3sk6yysftuzun199z objs]# cp -rfp ./nginx /usr/local/nginx/sbin/nginxcp：是否覆盖"/usr/local/nginx/sbin/nginx"？ yes[root@izbp1j3sk6yysftuzun199z objs]# 测试新的nginx程序是否正确 12345678910[root@izbp1j3sk6yysftuzun199z nginx]# ./sbin/nginx -tnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is oknginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful[root@izbp1j3sk6yysftuzun199z nginx]# ./sbin/nginx -Vnginx version: nginx/1.9.9built by gcc 4.8.5 20150623 (Red Hat 4.8.5-28) (GCC)built with OpenSSL 1.0.2k-fips 26 Jan 2017TLS SNI support enabledconfigure arguments: --prefix=/usr/local/nginx --pid-path=/var/nginx/run/nginx.pid --lock-path=/var/nginx/lock/nginx.lock --with-http_ssl_module --with-http_stub_status_module --with-http_gzip_static_module --http-client-body-temp-path=/usr/local/nginx/temp/nginx/client --http-proxy-temp-path=/usr/local/nginx/temp/nginx/proxy --http-fastcgi-temp-path=/usr/local/nginx/temp/nginx/fastcgi --http-uwsgi-temp-path=/usr/local/nginx/temp/nginx/uwsgi[root@izbp1j3sk6yysftuzun199z nginx]# 使用nginx -s reload顺滑重新启动nginx 12345678910111213141516171819[root@iZbp1h1kfgutxc4i1si300Z nginx]# ps -ef|grep nginxroot 2089 30724 0 17:13 pts/5 00:00:00 grep --color=auto nginxroot 3649 1 0 2月18 ? 00:00:00 nginx: master process ./sbin/nginx -c ./conf/nginx.confroot 6556 3649 0 6月17 ? 00:00:12 nginx: worker process[root@iZbp1h1kfgutxc4i1si300Z nginx]# ./sbin/nginx -s reload[root@iZbp1h1kfgutxc4i1si300Z nginx]# ps -ef|grep nginxroot 2095 3649 0 17:13 ? 00:00:00 nginx: worker processroot 2102 30724 0 17:13 pts/5 00:00:00 grep --color=auto nginxroot 3649 1 0 2月18 ? 00:00:00 nginx: master process ./sbin/nginx -c ./conf/nginx.confroot 6556 3649 0 6月17 ? 00:00:12 nginx: worker process is shutting down[root@iZbp1h1kfgutxc4i1si300Z nginx]# ps -ef|grep nginxroot 2095 3649 0 17:13 ? 00:00:00 nginx: worker processroot 2114 30724 0 17:14 pts/5 00:00:00 grep --color=auto nginxroot 3649 1 0 2月18 ? 00:00:00 nginx: master process ./sbin/nginx -c ./conf/nginx.confroot 6556 3649 0 6月17 ? 00:00:12 nginx: worker process is shutting down[root@iZbp1h1kfgutxc4i1si300Z nginx]# ps -ef|grep nginxroot 2095 3649 0 17:13 ? 00:00:00 nginx: worker processroot 2191 30724 0 17:15 pts/5 00:00:00 grep --color=auto nginxroot 3649 1 0 2月18 ? 00:00:00 nginx: master process ./sbin/nginx -c ./conf/nginx.conf 参考文章： https://www.cnblogs.com/effortsing/p/10012359.html https://blog.csdn.net/li_adou/article/details/78468451]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github上的工程上传到公共Maven仓库]]></title>
    <url>%2F3411365570%2F</url>
    <content type="text"><![CDATA[本文是针对的没有自己的域名，通过Github的渠道来上传至公共Maven仓库。有自己的域名的不在本文介绍范围。 在Github上创建一个工程 首先要在github上创建一个工程。注意，可见范围要选择为Public，需要审核人员能够访问这个地址。 然后，再完善这个Maven工程。 注意，建议使用com.github.[username]或者io.github.[username]，其中[username]是你在github上的username。至此，在Github上的工作已经完成。 在issues上创建工单创建账号如果在issues上没有账号，可以去申请注册issues,需要注意的是，用户名建议使用全英文，不要有中文字符。 创建工单按需要填写工单表格即可填写完成之后，等待管理员审批即可，等待状态变成RESOLVED。 上传jar到公共Maven库Mac电脑安装GnuPG我的系统是MacOS的，使用brew进行安装 1brew install gpg 安装完成后，使用gpg --version查看是否安装成功使用gpg --gen-key生成密钥对生成过程中，需要设置一个密码管理密钥，这个密码需要记录下来，以后使用的时候，是需要这个密码的。使用gpg --list-keys查看公钥将公钥发布到 PGP 密钥服务器,我上传了2个服务器(keys.gnupg.net和keyserver.ubuntu.com)，其中708BA29F9107359C8CD3F1C1AE09D627E10FDC2D是用户ID。 12gpg --keyserver keys.gnupg.net --send-keys 708BA29F9107359C8CD3F1C1AE09D627E10FDC2Dgpg --keyserver keyserver.ubuntu.com --send-keys 708BA29F9107359C8CD3F1C1AE09D627E10FDC2D 注意，可能会失败，报如下错误，此时不用紧张，先ping keys.gnupg.net服务器，然后将服务器地址换成IP即可验证是否上传成功 修改maven的settings.xml文件在maven的settings.xml文件中增加如下内容。其中，[username]和[password]中填写的是你在issues中的注册账号和密码。 1234567&lt;servers&gt; &lt;server&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;username&gt;[username]&lt;/username&gt; &lt;password&gt;[password]&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; 修改工程中的pom.xml文件如图，id是maven的配置文件settings.xml中的id。 12345678910&lt;distributionManagement&gt; &lt;snapshotRepository&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;repository&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;url&gt;https://oss.sonatype.org/service/local/staging/deploy/maven2/&lt;/url&gt; &lt;/repository&gt;&lt;/distributionManagement&gt; 附上上传源码到仓库中的maven插件。 12345678910111213&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar-no-fork&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 打包上传使用命令打包上传。 1mvn clean package deploy -Dmaven.test.skip=true 打包上传的过程中，签名的时候，mac下可能会报错，如下图所示：此时，需要在~/.gnupg文件夹下新增或者修改2个文件。gpg.conf 12use-agentpinentry-mode loopback gpg-agent.conf 1allow-loopback-pinentry 发布访问https://oss.sonatype.org/#stagingRepositories,拉到最下方，可以看见你的提交记录选择上方的Close，稍等片刻他先检查一下你上传的东西是否符合规范，检查完毕后该条状态被标记为closed，此时选中后点上面的Release即可。然后，找到你的issues，回复审核员说你已经打包上传了，等几小时，就可以在公共maven库中找到你的jar了]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[完美将工程从SVN迁移到Git仓库，并保留commit历史]]></title>
    <url>%2F3039998366%2F</url>
    <content type="text"><![CDATA[本案例并不需要安装svn环境 导出SVN系统工程首先，我们需要一台Linux系统的机器(或者虚拟机)，并安装git-svn: 1yum install git-svn 进入将要进行保存代码仓库的目录(例如：/home/mygit),创建users.txt文件，其作用是为了将svn中的提交作者和mygit中的作者进行关联映射。该文件结构类似于: 12ZhangSan = Zhang San &lt;san.zhang@mail.com&gt; LiSi = Li Si &lt;si.li@mail.com&gt; 注意：该文件可以先从使用svn命令从svn服务器将代码checkout下来，然后使用命令生成一个svn作者列表，进行修改，因本人项目参与人数不多，故使用手工编写。 安装完git-svn工具之后，使用git svn clone xxx命令从svn服务器clone项目: 1git svn clone --stdlayout --no-metadata -A users.txt http://svn.xxx.com/programer temp-dir 这个命令会在temp-dir中新建一个Git repo,并从svn中拉取代码，其中–stdlayout参数表示该项目在svn中是标准的trunk/branches/tags目录结构，如果不是，那么需要使用 –trunk, branches, –tags参数,除了trunk,其它的均是复数形式，如： 1git svn clone --no-metadata -A users.txt http://svn.xxx.com/programer --trunk=trunk temp-dir 如果项目中没有任何分支，连trunk也没有，则不需要任何参数，如 1git svn clone --no-metadata -A users.txt http://svn.xxx.com/programer temp-dir 如果出现用户名没有找到，更新users.txt文件之后，然后 12cd temp-dir git svn fetch 完成后,git会将checkout svn的trunk 到本地master分支,其它的svn branch将会设为git remote， 可以查看所有的svn branch 1git branch -r 为其它svn branch创建本地分支 1git checkout -b local_branch_name remotes/branch_name 为其它svn tag创建tag 1git tag tag_name remotes/tags/tag_name 将上面的git-svn仓库 clone到一个干净的git本地库中 1234cd .. git clone temp-dir projectName rm -rf temp-dir // 删除之前的git-svn库 cd projectName // 进入干净的git本地库中 于是之前的git-svn库就成了现在的git本地库的remote branch了，可以使用git branch查看本地分支有哪些。 再使用git checkout …对每一个分支再建立一次本地分支 1git checkout -b local_branch origin/remote_branch tag貌似不需要再重新建立了，可以使用git tag查看本地是否有tag。最后，将干净的git本地库中将之前的remote删除. 1git remote rm origin 将本地git库推送到远端将本地的git库推送到远程中央仓库 12git remote add origin http://$&#123;user&#125;@bitbucket.xxx.com/.... git push -u origin master 推送所有的branch 1git push origin --all 推送所有的tag 1git push origin --tags]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同时部署github和coding解决百度无法收录的问题]]></title>
    <url>%2F1495679384%2F</url>
    <content type="text"><![CDATA[现象使用百度搜索资源平台的抓取诊断功能，发现访问的都是403异常结果，如图所示： 后来百度了好久，才发现是因为github官方屏蔽了百度蜘蛛爬虫，导致不能被百度爬取网页。 解决办法 注册腾讯云开发者平台注册腾讯云开发者平台。网上说的是注册coding，但是coding的个人版已经被腾讯云收购了好像，大家可以直接去注册腾讯云开发者平台就可以了。 设置腾讯云开发者平台的ssk-key这里就不赘述如何添加了，大家应该很熟悉了。 创建项目，设置为公开访问。 文件配置 配置站点配置文件_config.yml 123456789# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: - type: git repo: - https://github.com/greenYears/greenYears.github.io - git@git.dev.tencent.com:greenYears/blog.git branch: master - type: baidu_url_submitter 执行hexo clean &amp; hexo g以及hexo deploy将代码同时上传到github以及腾讯云上。 项目发布 发布腾讯云上的项目点击「代码」-&gt; 「Pages服务」发布静态文件 域名解析配置 配置域名解析配置2个CNAME域名解析，一个解析路线设置为境外，一个为默认，这样境外的访问的会是github地址，国内的则是腾讯云的地址。 配置腾讯云的Pages服务设置界面 最终结果展示最后使用百度的搜索资源平台的抓取诊断]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的history命令增加时间戳]]></title>
    <url>%2F3577794677%2F</url>
    <content type="text"><![CDATA[一般Linux的系统的history命令只会展示一个index和执行命令，但是很多时候，我们都想查看一下这个命令是是什么人，在什么时候，在哪个IP下面执行的这个命令。这个时候，我们就需要编辑一下/etc/profile这个文件。 使用vim /etc/profile在文件最后面增加2行如下所示脚本： 123#history增加时间戳USER_IP=`who -u -m | awk '&#123;print $NF&#125;'| sed 's/[()]//g'`export HISTTIMEFORMAT="%F %T `whoami` $&#123;USER_IP&#125; " 然后退出编辑模式，输入source /etc/profile使文件生效。在使用history命令查看，即可看见之后的命令的执行者是哪个用户，什么时候执行的，以及是哪个ip地址。 1234567[root@izbp145clkvoxcy8wk7b3uz ~]# history | tail -5 1004 2019-06-17 10:26:16 root 124.90.68.224 source /etc/profile 1005 2019-06-17 10:26:19 root 124.90.68.224 history 1006 2019-06-17 10:27:07 root 124.90.68.224 cat /etc/profile 1007 2019-06-17 10:31:05 root 124.90.68.224 hisotry | tail -5 1008 2019-06-17 10:31:12 root 124.90.68.224 history | tail -5[root@izbp145clkvoxcy8wk7b3uz ~]#]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo next增加DaoVoice聊天功能]]></title>
    <url>%2F1503679503%2F</url>
    <content type="text"><![CDATA[眼馋了好久别人的聊天功能。hexo+next的其他博客之前都没有记录下来，比如如何如何给文章增加评论，以及打赏功能等等。这次作为第一篇关于hexo+next的博客分享出来。 注册DaoVoice首先点击DaoVoice官网进行注册。 接入进入后台控制台进入后台控制台，找到app_id第一次注册，会提示用户尽快接入，很好找到app_id，如图所示：也可以在「应用设置」菜单下的「安装到网站」菜单中找到 设置next主题 以 next 主题为例，打开 themes/next/layout/_partials/head/head.swig 文件中添加如下代码，位置随意： 123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice") daovoice('init', &#123; app_id: "&#123;&#123;theme.daovoice_app_id&#125;&#125;" &#125;); daovoice('update'); &lt;/script&gt;&#123;% endif %&#125; 在主题配置文件_config.yml，添加如下代码: 123# Online contact daovoice: truedaovoice_app_id: 这里输入前面获取的app_id next 主题下聊天的按钮会和其他按钮重叠到一起，可以到聊天设置，修改下按钮的位置:]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决服务器上使用less命令出现乱码]]></title>
    <url>%2F1080400834%2F</url>
    <content type="text"><![CDATA[表现形势在linux上使用less命令查看文件的时候，服务器会提示如下： 12[root@izbp1j3sk6yysftuzun199z sdp-service]# less out.log"out.log" may be a binary file. See it anyway? 此时如果输入no，则退出查看，如果输入yes会进行查看文件，但是文档中文会出现乱码 解决方法首先使用echo $LESSCHARSET查看less的编码 12[root@izbp1j3sk6yysftuzun199z sdp-service]# echo $LESSCHARSET [root@izbp1j3sk6yysftuzun199z sdp-service]# 看情况设置less的编码格式(我的服务器上使用utf-8查看中文) 1234[root@izbp1j3sk6yysftuzun199z sdp-service]# export LESSCHARSET=utf-8 [root@izbp1j3sk6yysftuzun199z sdp-service]# echo $LESSCHARSET utf-8 [root@izbp1j3sk6yysftuzun199z sdp-service]# 此时使用less命令查看文件，文件中的中文即正常了]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot的事件监听]]></title>
    <url>%2F59d95f97%2F</url>
    <content type="text"><![CDATA[系统定义的事件待补充 自定义的事件事件消息实体事件中的消息实体类型。 123456789@Data@NoArgsConstructor@AllArgsConstructorpublic class DemoEventMessage implements Serializable &#123; private static final long serialVersionUID = -8599896146999392055L; private String code; private String title; private String body;&#125; 事件源自定义的事件源需要继承自ApplicationEvent类，不严格要求事件源集成ApplicationEvent，但是还是希望集成。 123456789101112@Getterpublic class DemoEvent extends ApplicationEvent &#123; private DemoEventMessage message; public DemoEvent(Object source) &#123; super(source); &#125; public DemoEvent(Object source, DemoEventMessage message) &#123; super(source); this.message = message; &#125;&#125; 事件监听器先定义了一个基础的事件监听接口，其中onEvent(T event)需要实现类自定义实现。 123456789public interface MyEventListener&lt;T extends ApplicationEvent&gt; &#123; /** * 事件监听实现. * * @param event */ void onEvent(T event);&#125; 实现类要实现接口中的方法onEvent(T event)。 12345678910111213141516@Component@Slf4jpublic class DemoEventListener implements MyEventListener&lt;DemoEvent&gt; &#123; @Override @EventListener public void onEvent(DemoEvent event) &#123; log.info("======== 开始接收消息 ========"); log.info("消息source： &#123;&#125;", event.getSource().getClass().getName()); log.info("消息code： &#123;&#125;", event.getMessage().getCode()); log.info("消息title： &#123;&#125;", event.getMessage().getTitle()); log.info("消息body： &#123;&#125;", event.getMessage().getBody()); log.info(""); // TODO: 2019-05-10 具体的业务逻辑 &#125;&#125; 事件推送1234567891011121314@Slf4jpublic class DemoEventPublishTest extends BaseTest &#123; @Autowired private ApplicationEventPublisher eventPublisher; @Test public void testSimplePublish() &#123; String title = "线程[1]的消息"; String body = CalculateUtil.format(new Date()) + " 消息"; DemoEventMessage message = new DemoEventMessage("00000", title, body); log.info("线程[1]开始发布事件: &#123;&#125;", message); eventPublisher.publishEvent(new DemoEvent(this, message)); &#125;&#125;]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
</search>
